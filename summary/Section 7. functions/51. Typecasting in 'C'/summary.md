```c
#include <stdio.h>

int main(void) {
    // За замовчуванням, компілятор вважає, що 0x87 та 0xFF00 - це int. Він виділяє по 4 байти пам'яті для кожного числа.
    // Якщо запустити цей код, компілятор показує попередження (unsigned converstion from 'int' to 'unsigned char'). Бо ми записуємо 4 байти в 1 байт і відбувається втрата даних.
    // unsigned char може зберігати числа до 255(0x00FF). Якщо ми записуємо 0x87 + 0xFF00, то отримаємо 0x87, бо 0xFF00 виходить за межі unsigned char. 0x87 можна записати як 0x0087.
    unsigned char data = 0x87 + 0xFF00;

    // наступний код не згенерує помилку, бо дані не втрачаються, сума значень права від "дорівнює" достатньо маленька, щоб поміститися в unsigned char
    // Але це працює тому, що компілятор додає ці значення під час компіляції, а не під час виконання.
    unsigned char data1 = 0x01 + 0x0089;

    // Щоб уникнути першого попередження, можна використати явний(explicit) typecasting
    // Дані теж обріжуться до 1 байта, але попередження не буде. Тобто програміст, що написав typecasting знає, що дані будуть обрізані і він має це розуміти.
    unsigned char data2 = (unsigned char) (0x87 + 0xFF00);


    // Наступний код призведе до втрати даних, бо при ділені цілих чисел компілятор обрізає результат до цілого числа.
    float result = 10 / 3;

    // Щоб уникнути цього, можна використати typecasting
    // Ми явно конвертуємо число 10 до float, а компілятор неявно конвертує число 3 до float, щоб результат був правильним.
    float result1 = (float) 10 / 3;
}